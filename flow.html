<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Force-Directed Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <style>
        .link {
            stroke-opacity: 0.6;
        }
        .node text {
            pointer-events: none;
            font-size: 10px;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 8px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0;
            border-radius: 8px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <svg width="960" height="600"></svg>
    <div class="tooltip" style="opacity: 0;"></div>
    <script>
        const width = 960;
        const height = 600;
        // 饼图额外半径比率
        const pieExtraRadius = 1.4;

        // 設置SVG和tooltip
        const svg = d3.select("svg");
        const tooltip = d3.select(".tooltip");

        // 定義顏色標度
        const tableauColors = d3.schemeTableau10; // T10种颜色
        const set3Colors = d3.schemeSet3; // 9种颜色

        const combinedColors = [...tableauColors, ...set3Colors]; // 将两个颜色数组合并，得到19种颜色
        const color = d3.scaleOrdinal(combinedColors); // 创建序数比例尺

        // 讀取CSV文件並生成圖表
        d3.csv("matrix.csv").then(data => {
            const nodes = [];
            const links = [];
            const districtSet = new Set();
            const header = data.columns.slice(1);

            data.forEach(row => {
                const source = row[''];
                if (!districtSet.has(source)) {
                    nodes.push({ id: source, value: +row[source], linkData: [] });
                    districtSet.add(source);
                }
                header.forEach(target => {
                    const value = +row[target];
                    if (source !== target && value > 0) {
                        links.push({ source: source, target: target, value: value });
                        nodes.find(n => n.id === source).linkData.push({ target: target, value: value });
                    }
                });
            });

            // 歸一化連接值以設置顏色
            const linkValues = links.map(d => d.value);
            const maxLinkValue = Math.max(...linkValues);
            const minLinkValue = Math.min(...linkValues);

            const pie = d3.pie().value(d => d.value);
            const arc = d3.arc();


            const infernoScale = d3.scaleSequential(d3.interpolateInferno)
                .domain([minLinkValue, maxLinkValue]);

            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-500))
                .force("center", d3.forceCenter(width / 2, height / 2));

            const link = svg.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("stroke-width", d => Math.sqrt(d.value)/200)
                .attr("stroke", d => infernoScale(d.value))
                .attr("stroke-opacity", 0.6)
                .on("mouseover", function(event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html("From: " + d.source.id + "<br/>To: " + d.target.id + "<br/>Value: " + d.value)
                        .style("left", (event.pageX) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            const node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("circle")
                .data(nodes)
                .enter().append("circle")
                .attr("r", d => Math.sqrt(d.value) / 100)
                .attr("fill", d => color(d.id))
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended))
                .on("mouseover", function(event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(d.id + "<br/>" + "Value: " + d.value)
                        .style("left", (event.pageX) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

        const pieGroups = svg.selectAll(".pieGroup")
            .data(nodes)
            .enter().append("g")
            .attr("class", "pieGroup");

        function ticked() {
            node.attr("cx", d => d.x)
                .attr("cy", d => d.y);

            link.attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            pieGroups.attr("transform", d => `translate(${d.x}, ${d.y})`)
                .each(drawPie);
        }

        function drawPie(nodeData) {
            const pieData = pie(nodeData.linkData);
            const nodeRadius = Math.sqrt(nodeData.value) / 100;
            const g = d3.select(this);
            const path = g.selectAll("path")
                .data(pieData);

            path.enter().append("path")
                .merge(path)
                .attr("d", arc.innerRadius(nodeRadius).outerRadius(nodeRadius*pieExtraRadius))
                .attr("fill", d => color(d.data.target));

            path.exit().remove();
        }

        node.on("dblclick", function(event, d) {
            if (d3.select(this).classed("focused")) {
                // 如果节点已经聚焦，恢复显示所有节点和边
                node.style("opacity", 1);
                link.style("opacity", 1);
                pieGroups.style("opacity", 1);
                node.classed("focused", false);
            } else{
                const connectedNodes = new Set();
                connectedNodes.add(d.id); // 添加自身
                d3.select(this).classed("focused", true);

                links.forEach(link => {
                    if (link.source.id === d.id) {
                        connectedNodes.add(link.target.id);
                        console.log(link);
                    }
                    if (link.target.id === d.id) {
                        connectedNodes.add(link.source.id);
                        console.log(link);
                    }
                });
                console.log(connectedNodes);
                // 更新节点和边的显示状态
                node.style("opacity", node => connectedNodes.has(node.id) ? 1 : 0);
                // 只保留与d直接相连的边
                link.style("opacity", link => link.source.id === d.id || link.target.id === d.id ? 1 : 0);

                // 更新饼图的显示状态
                pieGroups.style("opacity", pieGroup => connectedNodes.has(pieGroup.id) ? 1 : 0);
        }});
            node.append("title")
                .text(d => d.id);

            simulation
                .nodes(nodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(links);


            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }).catch(error => {
            console.error("Error loading or parsing data:", error);
        });

        // 生成力導向圖
        function generateForceDirectedGraph() {
            const width = document.getElementById('graph').clientWidth;
            const height = document.getElementById('graph').clientHeight;

            const svg = d3.select("#graph svg")
                .attr("width", width)
                .attr("height", height);

            d3.csv("matrix.csv").then(matrixData => {
                const nodes = [];
                const links = [];
                const districtSet = new Set();
                const header = matrixData.columns.slice(1);

                matrixData.forEach(row => {
                    const source = row[''];
                    if (!districtSet.has(source)) {
                        nodes.push({ id: source, value: +row[source] , linkData: []});
                        districtSet.add(source);
                    }
                    header.forEach(target => {
                        const value = +row[target];
                        if (source !== target && value > 0) {
                            links.push({ source: source, target: target, value: value });
                            nodes.find(n => n.id === source).linkData.push({ target: target, value: value });
                        }
                    });
                });
                const linkValues = links.map(d => d.value);
                const maxLinkValue = Math.max(...linkValues);
                const minLinkValue = Math.min(...linkValues);
                const pieExtraRadius = 1.4;
                const Radius = function(d) {
                    return Math.sqrt(d) / 60;
                };

                const infernoScale = d3.scaleSequential(d3.interpolateInferno)
                    .domain([minLinkValue, maxLinkValue]);
                const simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id).distance(100))
                    .force("charge", d3.forceManyBody().strength(-500))
                    .force("center", d3.forceCenter(width / 2, height / 2));

                const link = svg.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(links)
                    .enter().append("line")
                    .attr("stroke-width", d => Math.sqrt(d.value) / 200)
                    .attr("stroke", d => infernoScale(d.value))
                    .attr("stroke-opacity", 0.6)
                    .on("mouseover", function(event, d) {
                        d3.select(this).classed("highlight", true);
                    })
                    .on("mouseout", function(d) {
                        d3.select(this).classed("highlight", false);
                    });

                const node = svg.append("g")
                    .attr("class", "nodes")
                    .selectAll("circle")
                    .data(nodes)
                    .enter().append("circle")
                    .attr("r", d => Radius(d.value))
                    .attr("fill", d => color(d.id))
                    .call(d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended))
                    .on("mouseover", function(event, d) {
                        d3.select(this).classed("highlight", true);

                        // 高亮顯示對應的地圖區域
                        if (highlightLayer) {
                            map.removeLayer(highlightLayer);
                        }
                        highlightLayer = L.geoJSON(geojsonData, {
                            style: function(feature) {
                                if (feature.properties.TOWNNAME === d.id) {
                                    return { color: "#ff0", weight: 3, fillOpacity: 0.7 };
                                } else {
                                    return { color: "#3388ff", weight: 1, fillOpacity: 0.2 };
                                }
                            }
                        }).addTo(map);

                        // 更新饼图
                        updatePieChart(d.id);
                    })
                    .on("mouseout", function(d) {
                        d3.select(this).classed("highlight", false);

                        // 移除地圖區域高亮
                        if (highlightLayer) {
                            map.removeLayer(highlightLayer);
                        }
                    });

                node.append("title")
                    .text(d => d.id);

                simulation
                    .nodes(nodes)
                    .on("tick", ticked);



                simulation.force("link")
                    .links(links)

                const pie = d3.pie().value(d => d.value);
                const arc = d3.arc();

                const pieGroups = svg.selectAll(".pieGroup")
                    .data(nodes)
                    .enter().append("g")
                    .attr("class", "pieGroup");

                function ticked() {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y);

                    pieGroups.attr("transform", d => `translate(${d.x}, ${d.y})`)
                        .each(drawPie);
                    
                    textgroup.attr("transform", d => `translate(${d.x}, ${d.y})`)
                }
                function drawPie(nodeData) {
                    const pieData = pie(nodeData.linkData);
                    const nodeRadius = Radius(nodeData.value);
                    const g = d3.select(this);
                    const path = g.selectAll("path")
                        .data(pieData);

                    path.enter().append("path")
                        .merge(path)
                        .attr("d", arc.innerRadius(nodeRadius).outerRadius(nodeRadius*pieExtraRadius))
                        .attr("fill", d => color(d.data.target));

                    path.exit().remove();
                }
                node.on("dblclick", function(event, d) {
                    if (d3.select(this).classed("focused")) {
                        // 如果节点已经聚焦，恢复显示所有节点和边
                        node.style("opacity", 1);
                        link.style("opacity", 1);
                        pieGroups.style("opacity", 1);
                        node.classed("focused", false);
                    } else{
                        const connectedNodes = new Set();
                        connectedNodes.add(d.id); // 添加自身
                        d3.select(this).classed("focused", true);

                        links.forEach(link => {
                            if (link.source.id === d.id) {
                                connectedNodes.add(link.target.id);
                                console.log(link);
                            }
                            if (link.target.id === d.id) {
                                connectedNodes.add(link.source.id);
                                console.log(link);
                            }
                        });
                        console.log(connectedNodes);
                        // 更新节点和边的显示状态
                        node.style("opacity", node => connectedNodes.has(node.id) ? 1 : 0);
                        // 只保留与d直接相连的边
                        link.style("opacity", link => link.source.id === d.id || link.target.id === d.id ? 1 : 0);

                        // 更新饼图的显示状态
                        pieGroups.style("opacity", pieGroup => connectedNodes.has(pieGroup.id) ? 1 : 0);
                }});

                // 在每个节点上饼图的中心添加文字
                const textgroup = svg.selectAll(".textgroup")
                    .data(nodes)
                    .enter().append("g")
                    .attr("class", "textgroup");
                
                textgroup.append("text")
                    .attr("class", "label")
                    .attr("text-anchor", "middle")
                    .attr("dy", "0.35em")
                    .text(function(d) {
                        return d.id.substring(0, 2);

                    })
                    .attr("fill", "white")
                    .attr("font-size", function(d) {
                        r = Radius(d.value);
                        r = r * r / 10
                        r = Math.round(r);
                        console.log(r);
                        r = toString(r);
                        r = '' + r + 'px'
                        return r;
                    });
                    

                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }

                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }

                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }
            }).catch(error => {
                console.error("Error loading or parsing matrix data:", error);
            });
        }

        // 調用生成力導向圖
        generateForceDirectedGraph();

        // 設置甜甜圈圖
        const pieWidth = 250;
        const pieHeight = 250;
        const radius = Math.min(pieWidth, pieHeight) / 2;

        // 選擇甜甜圈圖容器並設置SVG
        const pieSvg = d3.select(".pie-chart")
            .append("svg")
            .attr("width", pieWidth)
            .attr("height", pieHeight)
            .append("g")
            .attr("transform", `translate(${pieWidth / 2}, ${pieHeight / 2})`);

        // 設置甜甜圈圖顏色標度
        const pieColor = color;

        // 模擬甜甜圈圖數據
        const initialPieData = {
            "萬華區": 747563,
            "其他地區": 2000000 // 假設數據，請替換為真實數據
        };

        function updatePieChart(region) {
            d3.csv("matrix.csv").then(matrixData => {
                const pieData = {};
                const totalValue = matrixData.reduce((acc, row) => {
                    if (row[''] !== region) {
                        pieData[row['']] = +row[region] || 0;
                        return acc + (+row[region] || 0);
                    }
                    return acc;
                }, 0);

                pieData[region] = totalValue;

                const pie = d3.pie()
                    .value(d => d[1])
                    .sort(null);

                const arc = d3.arc()
                    .innerRadius(radius * 0.6)
                    .outerRadius(radius);

                const labelArc = d3.arc()
                    .innerRadius(radius * 0.8)
                    .outerRadius(radius * 0.8);

                const pieDataReady = pie(Object.entries(pieData));

                const piePath = pieSvg.selectAll("path")
                    .data(pieDataReady);

                piePath.enter()
                    .append("path")
                    .merge(piePath)
                    .attr("d", arc)
                    .attr("fill", d => pieColor(d.data[0]))
                    .attr("stroke", "white")
                    .style("stroke-width", "2px")
                    .on("mouseover", function(event, d) {
                        d3.select(this).classed("highlight", true);
                        centerText.text(`${d.data[0]}: ${d.data[1]}`);
                    })
                    .on("mouseout", function(event, d) {
                        d3.select(this).classed("highlight", false);
                        centerText.text(`${region}: ${pieData[region]}`);
                    })
                    .transition()
                    .duration(1000)
                    .attrTween("d", function(d) {
                        const i = d3.interpolate({ startAngle: 0, endAngle: 0 }, d);
                        return function(t) { return arc(i(t)); };
                    });

                piePath.exit().remove();

                const centerText = pieSvg.selectAll(".center-text")
                    .data([pieData[region]]);

                centerText.enter()
                    .append("text")
                    .style("font-size", "15px")
                    .attr("class", "center-text")
                    .attr("dy", "0.35em")
                    .merge(centerText)
                    .text(`${region}: ${pieData[region]}`);
            });
        }

        updatePieChart("萬華區");

    </script>
</body>
</html>
