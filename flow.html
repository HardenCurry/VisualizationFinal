<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Force-Directed Graph with Leaflet and D3 Dashboard</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <style>
        body, html {
            height: 100%;
            margin: 0;
            display: flex;
            flex-direction: column;
        }
        #map {
            width: 100%;
            height: 50%;
        }
        #dashboard {
            width: 100%;
            height: 50%;
            display: flex;
        }
        #graph {
            width: 50%;
            height: 100%;
            position: relative;
        }
        #other {
            width: 50%;
            height: 100%;
            background-color: #f0f0f0;
        }
        .link {
            stroke-opacity: 0.6;
        }
        .node text {
            pointer-events: none;
            font-size: 10px;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 8px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0;
            border-radius: 8px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="dashboard">
        <div id="graph">
            <svg width="100%" height="100%"></svg>
            <div class="tooltip" style="opacity: 0;"></div>
        </div>
        <div id="other">
            <!-- 這裡可以添加其他內容 -->
        </div>
    </div>
    <script>
        // 設置地圖
        const map = L.map('map').setView([25.0330, 121.5654], 12);

        // 添加輕量風格的底圖
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            maxZoom: 19
        }).addTo(map);

        // 設置SVG圖層
        const svgLayer = L.svg().addTo(map);
        const svg = d3.select("#map").select("svg");
        const g = svg.append("g").attr("class", "leaflet-zoom-hide");

        const tooltip = d3.select(".tooltip");

        // 定義顏色標度
        const color = d3.scaleOrdinal(d3.schemeCategory10);

        // 添加台北市的GeoJSON
        d3.json("taipei.geojson").then(geojsonData => {
            L.geoJSON(geojsonData).addTo(map);
        });

        // 讀取CSV文件並生成圖表
        d3.csv("matrix.csv").then(matrixData => {
            d3.csv("district_centroids.csv").then(centroidData => {
                const nodes = [];
                const links = [];
                const districtSet = new Set();
                const header = matrixData.columns.slice(1);

                // 將行列轉換為節點和連接數據
                matrixData.forEach(row => {
                    const source = row[''];
                    const sourceCentroid = centroidData.find(d => d.TOWNNAME === source);
                    if (sourceCentroid && !districtSet.has(source)) {
                        nodes.push({ id: source, value: +row[source], lat: +sourceCentroid.lat, lon: +sourceCentroid.lon });
                        districtSet.add(source);
                    }
                    header.forEach(target => {
                        const value = +row[target];
                        const targetCentroid = centroidData.find(d => d.TOWNNAME === target);
                        if (source !== target && value > 0 && targetCentroid) {
                            links.push({ source: source, target: target, value: value, 
                                         sourceLat: +sourceCentroid.lat, sourceLon: +sourceCentroid.lon,
                                         targetLat: +targetCentroid.lat, targetLon: +targetCentroid.lon });
                        }
                    });
                });

                // 歸一化連接值以設置顏色
                const linkValues = links.map(d => d.value);
                const maxLinkValue = Math.max(...linkValues);
                const minLinkValue = Math.min(...linkValues);

                const infernoScale = d3.scaleSequential(d3.interpolateInferno)
                    .domain([minLinkValue, maxLinkValue]);

                const link = g.selectAll("line")
                    .data(links)
                    .enter().append("line")
                    .attr("class", "link")
                    .attr("stroke-width", d => Math.sqrt(d.value) / 200)
                    .attr("stroke", d => infernoScale(d.value))
                    .attr("stroke-opacity", 0.6)
                    .on("mouseover", function(event, d) {
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html("From: " + d.source + "<br/>To: " + d.target + "<br/>Value: " + d.value)
                            .style("left", (event.pageX) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(d) {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                const node = g.selectAll("circle")
                    .data(nodes)
                    .enter().append("circle")
                    .attr("class", "node")
                    .attr("r", d => Math.sqrt(d.value) / 100)
                    .attr("fill", d => color(d.id))
                    .on("mouseover", function(event, d) {
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html(d.id + "<br/>" + "Value: " + d.value)
                            .style("left", (event.pageX) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(d) {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                // 更新位置
                function update() {
                    link.attr("x1", d => map.latLngToLayerPoint([d.sourceLat, d.sourceLon]).x)
                        .attr("y1", d => map.latLngToLayerPoint([d.sourceLat, d.sourceLon]).y)
                        .attr("x2", d => map.latLngToLayerPoint([d.targetLat, d.targetLon]).x)
                        .attr("y2", d => map.latLngToLayerPoint([d.targetLat, d.targetLon]).y);

                    node.attr("cx", d => map.latLngToLayerPoint([d.lat, d.lon]).x)
                        .attr("cy", d => map.latLngToLayerPoint([d.lat, d.lon]).y);
                }

                map.on("moveend", update);
                update();
            }).catch(error => {
                console.error("Error loading or parsing centroid data:", error);
            });
        }).catch(error => {
            console.error("Error loading or parsing matrix data:", error);
        });

        // 生成力導向圖
        function generateForceDirectedGraph() {
            const width = document.getElementById('graph').clientWidth;
            const height = document.getElementById('graph').clientHeight;

            const svg = d3.select("#graph svg")
                .attr("width", width)
                .attr("height", height);

            d3.csv("matrix.csv").then(matrixData => {
                const nodes = [];
                const links = [];
                const districtSet = new Set();
                const header = matrixData.columns.slice(1);

                matrixData.forEach(row => {
                    const source = row[''];
                    if (!districtSet.has(source)) {
                        nodes.push({ id: source, value: +row[source] });
                        districtSet.add(source);
                    }
                    header.forEach(target => {
                        const value = +row[target];
                        if (source !== target && value > 0) {
                            links.push({ source: source, target: target, value: value });
                        }
                    });
                });

                const simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id).distance(100))
                    .force("charge", d3.forceManyBody().strength(-500))
                    .force("center", d3.forceCenter(width / 2, height / 2));

                const link = svg.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(links)
                    .enter().append("line")
                    .attr("stroke-width", d => Math.sqrt(d.value) / 200)
                    .attr("stroke", d => infernoScale(d.value))
                    .attr("stroke-opacity", 0.6)
                    .on("mouseover", function(event, d) {
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html("From: " + d.source + "<br/>To: " + d.target + "<br/>Value: " + d.value)
                            .style("left", (event.pageX) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(d) {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                const node = svg.append("g")
                    .attr("class", "nodes")
                    .selectAll("circle")
                    .data(nodes)
                    .enter().append("circle")
                    .attr("r", d => Math.sqrt(d.value) / 100)
                    .attr("fill", d => color(d.id))
                    .call(d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended))
                    .on("mouseover", function(event, d) {
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html(d.id + "<br/>" + "Value: " + d.value)
                            .style("left", (event.pageX) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(d) {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                node.append("title")
                    .text(d => d.id);

                simulation
                    .nodes(nodes)
                    .on("tick", ticked);

                simulation.force("link")
                    .links(links);

                function ticked() {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y);
                }

                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }

                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }

                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }
            }).catch(error => {
                console.error("Error loading or parsing matrix data:", error);
            });
        }

        // 調用生成力導向圖
        generateForceDirectedGraph();
    </script>
</body>
</html>
